### 使用 Brotli 进行纯文本压缩
Brotli 可用于任何纯文本的内容-HTML，CSS，SVG，JavaScript 等。

###使用响应式图像和 WebP
尽可能使用具有 srcset，sizes 和  元素的响应式图像。

WebP 图像文件格式不支持像 JPEG 那样的渐进式渲染[207]，这就是为什么用户使用好的 JPEG 可能会更快地看到实际图像，尽管 WebP 图像的网络加载速度可能会更快。使用 JPEG，我们可以用一半甚至四分之一的时间就提供给“像样的”用户体验，并在稍后加载其余的数据，而不是像 WebP 那样只有半空的图像。您的决定将取决于您想要的是什么：使用 WebP，您将减少图像大小，而使用 JPEG，您将提高图像的可感知性

###图像是否经过适当优化？



####1. 对于img标签展示的图片本身使用 srcset 和 size

`响应式图片srcset属性`

根据屏幕密度现实对应尺寸图片:

```html
<img src="mm-width-128px.jpg" srcset="128px.jpg 128w, 256px.jpg 256w, 512px.jpg 512w">
```

		表示，当<img>元素的宽度规格为128的时候，加载128px.jpg，宽度规格为256的时候，加载256px.jpg， 宽度规格为512的时候，加载512px.jpg。
		这里的宽度规格就是w描述符的另外一种理解，其与sizes属性设定和屏幕密度密切相关。
		举个例子，假设屏幕密度是2的iPhone6手机，sizes属性计算值是128px，则此时<img>实际的宽度规格应该是128*2也就是256w，因此会加载256px.jpg这张图。

####2.对图片和 Iframe 进行懒加载
可以使用混合`懒加载`、`本地懒加载`，或`懒加载库`，
它检测通过用户交互触发的可见性更改来实现懒加载（使用 `IntersectionObserver`）

**为了缩短开始渲染关键图像所需的时间，请延迟加载不太重要的图像，并在关键图像渲染完成后再加载任何异步脚本**

####3.对于屏幕外图像

    我们可以先显示一个占位符，
    然后当图像出现在视口中时，使`IntersectionObserver` 触发网络调用，以将图像下载到后台。
    然后，我们可以推迟渲染直到调用` img.decode（）`完成解码；如果`Image Decode API`不可用，就直接下载图像。
    渲染图像时，我们可以使用`淡入动画`。

** CSS 中的`aspect-ratio`属性和`internalsize` 属性，允许我们设置图像的纵横比和尺寸，浏览器便可以可以提前保留预定义的布局槽，这样在页面加载期间就可以避免出现布局跳跃**

### 网络字体是否经过优化？

**使用 preload 资源提示来预加载字体**

		在页面标记中，predload 字体需要放在关键 CSS 和 JavaScript 的链接之后
		。对于 preload，优先级经常令人困惑，因此请考虑在外部脚本阻塞之前将 rel=" preload" 元素注入到 DOM 中。
		“使用脚本注入的资源将在浏览器中隐藏，直到脚本执行为止，我们可以使用此行为来延迟浏览器发现 preload 元素。” 否则，字体加载将在第一次渲染时就耗费您的时间。

**在 @font-face 规则中定义 font family 时，使用 local() 值(按名称引用本地字体)**

如果字体是本地可用的，浏览器就可以立即显示本地字体，而不需要下载网页字体。



**使用 font-display **

这个 CSS 描述符来控制字体的加载行为并使内容立即（font-display: optional）或几乎立即（font-display: swap）可读 。

但如果要避免文本重排，我们仍然需要使用字体加载 API，特别是在对文本重绘进行分组时或者在使用第三方代理的时候。